[2024-11-03 11:06:12] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Apifox/1.0.0 (https://apifox.com); user=0; uri=/article/edit; payload=null; cost=440
[2024-11-03 11:07:52] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Apifox/1.0.0 (https://apifox.com); user=0; uri=/article/edit; payload=null; cost=117
[2024-11-03 11:08:52] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=586
[2024-11-03 11:09:23] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=17
[2024-11-03 11:11:56] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=288
[2024-11-03 11:16:36] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=302
[2024-11-03 11:24:42] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=312
[2024-11-03 11:25:20] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=306
[2024-11-03 11:25:21] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=19
[2024-11-03 11:30:50] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Apifox/1.0.0 (https://apifox.com); user=0; uri=/article/edit; payload=null; cost=492
[2024-11-03 11:30:56] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Apifox/1.0.0 (https://apifox.com); user=0; uri=/article/edit; payload=null; cost=29
[2024-11-03 11:31:13] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=77
[2024-11-03 11:32:14] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=290
[2024-11-03 11:34:10] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=313
[2024-11-03 11:37:31] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=299
[2024-11-03 11:46:00] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=163
[2024-11-03 11:59:57] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=477
[2024-11-03 12:03:35] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=70
[2024-11-03 12:04:33] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=65
[2024-11-03 12:06:38] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=75
[2024-11-03 12:09:56] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=360
[2024-11-03 12:10:00] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/article/detail/4; payload=null; cost=75
[2024-11-03 12:10:16] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/article/detail/4; payload=null; cost=47
[2024-11-03 12:12:10] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=72
[2024-11-03 12:13:42] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=0; uri=/; payload=null; cost=68
[2024-11-03 12:16:10] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/; payload=null; cost=346
[2024-11-03 12:16:14] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/detail/4; payload=null; cost=74
[2024-11-03 12:16:37] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/; payload=null; cost=370
[2024-11-03 12:16:42] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/detail/3; payload=null; cost=85
[2024-11-03 12:19:27] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/detail/3; payload=null; cost=371
[2024-11-03 12:19:35] - method=GET; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/detail/3; payload=null; cost=54
[2024-11-03 12:19:37] - method=GET; referer=http://localhost:8080/article/detail/3; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/; payload=null; cost=51
[2024-11-03 12:19:40] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/detail/3; payload=null; cost=51
[2024-11-03 12:19:45] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/detail/3; payload=null; cost=28
[2024-11-03 12:19:48] - method=GET; referer=http://localhost:8080/article/detail/3; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/edit?articleId=3; payload=null; cost=37
[2024-11-03 12:20:04] - method=POST; referer=http://localhost:8080/article/edit?articleId=3; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/post; payload={"articleId":"3","title":"Java小技巧：巧用函数方法实现二维数组遍历","subTitle":"巧用函数方法实现二维数组遍历","content":"对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深\n\n如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中\n\n二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，\n\n```java\npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < cells.length; i ++) {\n        for (int j = 0; j < cells[0].length; j++) {\n            if ((cells[i][j] & 1) == 0) {\n                ans.add(cells[i][j]);\n            }\n        }\n    }\n    System.out.println(ans);\n}\n```\n\n上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么\n\n那么问题来了，代码层级变多之后会有什么问题呢？\n\n> 只要代码能跑，又能有什么问题呢？！\n\n## 1. 函数方法消减代码层级\n\n由于多维数组的遍历层级天然就很深，那么有办法进行消减么？\n\n要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？\n\n> 定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可\n\n基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法\n\n```java\npublic static void scan(int maxX, int maxY, BiConsumer<Integer, Integer> consumer) {\n    for (int i = 0; i < maxX; i++) {\n        for (int j = 0; j < maxY; j++) {\n            consumer.accept(i, j);\n        }\n    }\n}\n```\n\n主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值\n\n那么上面这个怎么用呢？\n\n同样是上面的例子，改一下之后，如\n\n```java\npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    List<Integer> ans = new ArrayList<>();\n    scan(cells.length, cells[0].length, (i, j) -> {\n        if ((cells[i][j] & 1) == 0) {\n            ans.add(cells[i][j]);\n        }\n    });\n    System.out.println(ans);\n}\n```\n\n相比于前面的，貌似也就少了一层而已，好像也没什么了不起的\n\n但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦\n\n## 2. 遍历中return支持\n\n前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？\n\n如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？\n\n仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?\n\n很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回\n\n基于此思路，我们可以实现一个简单的demo版本\n\n定义一个函数方法，接受循环的下标 + 返回值\n\n```java\n@FunctionalInterface\npublic interface ScanProcess<T> {\n    ImmutablePair<Boolean, T> accept(int i, int j);\n}\n```\n\n循环通用方法就可以相应的改成\n\n```java\npublic static <T> T scanReturn(int x, int y, ScanProcess<T> func) {\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            ImmutablePair<Boolean, T> ans = func.accept(i, j);\n            if (ans != null && ans.left) {\n                return ans.right;\n            }\n        }\n    }\n    return null;\n}\n```\n\n基于上面这种思路，我们的实际使用姿势如下\n\n```java\n@Test\npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    List<Integer> ans = new ArrayList<>();\n    scanReturn(cells.length, cells[0].length, (i, j) -> {\n        if ((cells[i][j] & 1) == 0) {\n            return ImmutablePair.of(true, i + \"_\" + j);\n        }\n        return ImmutablePair.of(false, null);\n    });\n    System.out.println(ans);\n}\n```\n\n上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？\n\n既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？\n\n\n基于这个思路，我们可以先定义一个参数包装类\n\n```java\npublic static class Ans<T> {\n    private T ans;\n    private boolean tag = false;\n\n    public Ans<T> setAns(T ans) {\n        tag = true;\n        this.ans = ans;\n        return this;\n    }\n\n    public T getAns() {\n        return ans;\n    }\n}\n\npublic interface ScanFunc<T> {\n    void accept(int i, int j, Ans<T> ans)\n}\n```\n\n我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧\n\n与之对应的方法改造及实例如下\n\n```java\npublic static <T> T scanReturn(int x, int y, ScanFunc<T> func) {\n    Ans<T> ans = new Ans<>();\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            func.accept(i, j, ans);\n            if (ans.tag) {\n                return ans.ans;\n            }\n        }\n    }\n    return null;\n}\n    \npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    String ans = scanReturn(cells.length, cells[0].length, (i, j, a) -> {\n        if ((cells[i][j] & 1) == 0) {\n            a.setAns(i + \"_\" + j);\n        }\n    });\n    System.out.println(ans);\n}\n```\n\n这样看起来就比前面的要好一点了\n\n实际跑一下，看下输出是否和我们预期的一致；\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?)\n\n## 3.小结\n\n到此一个小的技巧就分享完毕了，各位感兴趣的小伙伴可以关注我的公众号“一灰灰blog”\n\n最近正在整理的 * [分布式设计模式综述 | 一灰灰Learning](https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/) 欢迎各位大佬点评\n\n* [万字总结：分布式系统的38个知识点 - 掘金](https://juejin.cn/post/7125383856651239432)\n* [万字详解：MySql,Redis,Mq,ES的高可用方案解析 - 掘金](https://juejin.cn/post/7126864114806177822)\n\n\n\n\n","categoryId":"1","tagIds":["1"],"summary":"对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深","articleType":"BLOG","source":2,"sourceUrl":"","actionType":"post"}; cost=175
[2024-11-03 12:20:06] - method=POST; referer=http://localhost:8080/article/edit?articleId=3; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/article/post; payload={"articleId":"3","title":"Java小技巧：巧用函数方法实现二维数组遍历","subTitle":"巧用函数方法实现二维数组遍历","content":"对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深\n\n如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中\n\n二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，\n\n```java\npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < cells.length; i ++) {\n        for (int j = 0; j < cells[0].length; j++) {\n            if ((cells[i][j] & 1) == 0) {\n                ans.add(cells[i][j]);\n            }\n        }\n    }\n    System.out.println(ans);\n}\n```\n\n上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么\n\n那么问题来了，代码层级变多之后会有什么问题呢？\n\n> 只要代码能跑，又能有什么问题呢？！\n\n## 1. 函数方法消减代码层级\n\n由于多维数组的遍历层级天然就很深，那么有办法进行消减么？\n\n要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？\n\n> 定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可\n\n基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法\n\n```java\npublic static void scan(int maxX, int maxY, BiConsumer<Integer, Integer> consumer) {\n    for (int i = 0; i < maxX; i++) {\n        for (int j = 0; j < maxY; j++) {\n            consumer.accept(i, j);\n        }\n    }\n}\n```\n\n主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值\n\n那么上面这个怎么用呢？\n\n同样是上面的例子，改一下之后，如\n\n```java\npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    List<Integer> ans = new ArrayList<>();\n    scan(cells.length, cells[0].length, (i, j) -> {\n        if ((cells[i][j] & 1) == 0) {\n            ans.add(cells[i][j]);\n        }\n    });\n    System.out.println(ans);\n}\n```\n\n相比于前面的，貌似也就少了一层而已，好像也没什么了不起的\n\n但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦\n\n## 2. 遍历中return支持\n\n前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？\n\n如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？\n\n仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?\n\n很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回\n\n基于此思路，我们可以实现一个简单的demo版本\n\n定义一个函数方法，接受循环的下标 + 返回值\n\n```java\n@FunctionalInterface\npublic interface ScanProcess<T> {\n    ImmutablePair<Boolean, T> accept(int i, int j);\n}\n```\n\n循环通用方法就可以相应的改成\n\n```java\npublic static <T> T scanReturn(int x, int y, ScanProcess<T> func) {\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            ImmutablePair<Boolean, T> ans = func.accept(i, j);\n            if (ans != null && ans.left) {\n                return ans.right;\n            }\n        }\n    }\n    return null;\n}\n```\n\n基于上面这种思路，我们的实际使用姿势如下\n\n```java\n@Test\npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    List<Integer> ans = new ArrayList<>();\n    scanReturn(cells.length, cells[0].length, (i, j) -> {\n        if ((cells[i][j] & 1) == 0) {\n            return ImmutablePair.of(true, i + \"_\" + j);\n        }\n        return ImmutablePair.of(false, null);\n    });\n    System.out.println(ans);\n}\n```\n\n上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？\n\n既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？\n\n\n基于这个思路，我们可以先定义一个参数包装类\n\n```java\npublic static class Ans<T> {\n    private T ans;\n    private boolean tag = false;\n\n    public Ans<T> setAns(T ans) {\n        tag = true;\n        this.ans = ans;\n        return this;\n    }\n\n    public T getAns() {\n        return ans;\n    }\n}\n\npublic interface ScanFunc<T> {\n    void accept(int i, int j, Ans<T> ans)\n}\n```\n\n我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧\n\n与之对应的方法改造及实例如下\n\n```java\npublic static <T> T scanReturn(int x, int y, ScanFunc<T> func) {\n    Ans<T> ans = new Ans<>();\n    for (int i = 0; i < x; i++) {\n        for (int j = 0; j < y; j++) {\n            func.accept(i, j, ans);\n            if (ans.tag) {\n                return ans.ans;\n            }\n        }\n    }\n    return null;\n}\n    \npublic void getEven() {\n    int[][] cells = new int[][]{{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}};\n    String ans = scanReturn(cells.length, cells[0].length, (i, j, a) -> {\n        if ((cells[i][j] & 1) == 0) {\n            a.setAns(i + \"_\" + j);\n        }\n    });\n    System.out.println(ans);\n}\n```\n\n这样看起来就比前面的要好一点了\n\n实际跑一下，看下输出是否和我们预期的一致；\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546a699ae4334df4b6525332da4e5770~tplv-k3u1fbpfcp-watermark.image?)\n\n## 3.小结\n\n到此一个小的技巧就分享完毕了，各位感兴趣的小伙伴可以关注我的公众号“一灰灰blog”\n\n最近正在整理的 * [分布式设计模式综述 | 一灰灰Learning](https://hhui.top/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E8%BF%B0/) 欢迎各位大佬点评\n\n* [万字总结：分布式系统的38个知识点 - 掘金](https://juejin.cn/post/7125383856651239432)\n* [万字详解：MySql,Redis,Mq,ES的高可用方案解析 - 掘金](https://juejin.cn/post/7126864114806177822)\n\n\n\n\n","categoryId":"1","tagIds":["1"],"summary":"对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深","articleType":"BLOG","source":2,"sourceUrl":"","actionType":"save"}; cost=33
[2024-11-03 12:20:35] - method=GET; referer=http://localhost:8080/article/detail/3; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/; payload=null; cost=22
[2024-11-03 12:20:40] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/wiki; payload=null; cost=11
[2024-11-03 12:20:45] - method=GET; referer=http://localhost:8080/; remoteIp=0:0:0:0:0:0:0:1; agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0; user=1; uri=/follow; payload=null; cost=3
